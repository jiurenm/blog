---
title: "数据类型"
date: 2022-08-09T10:26:56+08:00
draft: true
tags: ["Rust"]
categories: ["Rust学习"]
math: true
---

Rust 中的每个值都是特定的数据类型，它告诉 Rust 指定了哪种数据，因此它知道如何处理这些数据。

## 标量类型

标量类型表示单个值。 Rust 有四种主要的标量类型：整数、浮点数、布尔值和字符。

#### 整数类型

整数是没有小数部分的数字，下表显示了 Rust 中的内置整数类型。我们可以使用这些变体中的任何一个来声明整数值的类型。

| 长度 | 有符号类型 | 无符号类型 |
| --- | ---- | ---- |
| 8位 | i8 | u8 |
| 16位 | i16 | u16 |
| 32位 | i32 | u32 |
| 64位 | i64 | u64 |
| 128位 | i128 | u128 |
| 视架构而定 | isize | unsize |

每个变体都可以是有符号或无符号的，并且具有明确的大小。有符号和无符号是指数字是否可能为负数 - 换句话说，数字是否需要带有符号（有符号），或者它是否只会是正数，因此可以在没有符号的情况下表示（无符号）。有符号数使用二进制补码表示存储。

每个有符号变量可以存储从 $$ -(2^{n-1}) $$ 到 $$2^{n - 1} - 1$$ 的数字，其中 n 是变量使用的位数。所以 i8 可以存储从 $$ -(2^{7}) $$ 到 $$2^7 - 1$$ 的数字，等于 -128 到 127。无符号变体可以存储从 0 到 $$2^n - 1$$ 的数字，因此 u8 可以存储从 0 到 $$2^8 - 1$$ 的数字，等于0 到 255。

此外，isize 和 usize 类型取决于运行程序的计算机的体系结构，在表中表示为“arch”：如果您使用 64 位架构，则为 64 位，如果您使用的是 32 位在 32 位架构上。

您可以按下表中所示的任何形式编写整数文字。请注意，可以是多种数字类型的数字文字允许使用类型后缀，例如 `57u8` 来指定类型。数字字面量也可以使用 _ 作为视觉分隔符以使数字更易于阅读，例如 1_000，它的值与您指定 1000 的值相同。

| 数字字面量 | 示例 |
| -------- | --- |
| 十进制    | 98_222 |
| 十六进制  | 0xff |
| 八进制    | 0o77 |
| 二进制    | 0b1111_0000 |
| 字节（仅限于u8）| b'A' |

如果不确定使用哪种类型的整数，Rust 的默认值通常是不错的起点：整数类型默认为 i32。使用 isize 或 usize 的主要情况是索引某种集合时。

> 整数溢出
比方说有一个  u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时  panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。  
在当使用  --release  参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在  u8  的情况下，256 变成 0，257 变成 1，依此类推。程序不会  panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。  
要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
- 使用  `wrapping_*`  方法在所有模式下都按照补码循环溢出规则处理，例如  `wrapping_add`
- 如果使用  `checked_*`  方法时发生溢出，则返回  `None`  值
- 使用  `overflowing_*`  方法返回该值和一个指示是否存在溢出的布尔值
- 使用  `saturating_*`  方法使值达到最小值或最大值

#### 浮点类型

Rust 也有两种用于浮点数的原始类型，它们是带小数点的数字。 Rust 的浮点类型是 f32 和 f64，它们的大小分别为 32 位和 64 位。默认类型是 f64，因为在现代 CPU 上它的速度与 f32 大致相同，但精度更高。所有浮点类型都是有符号的。浮点数根据 IEEE-754 标准表示。 f32 类型为单精度浮点数，f64 为双精度。

#### 数值运算

Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和余数。整数除法向下舍入到最接近的整数。以下代码显示了如何在 let 语句中使用每个数字运算：

{{<highlight rust>}}
fn main() {
    // 加
    let sum = 5 + 10;

    // 减
    let difference = 95.5 - 4.3;

    // 乘
    let product = 4 * 30;

    // 除
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // 余
    let remainder = 43 % 5;
}
{{</highlight>}}

#### 布尔类型

与大多数其他编程语言一样，Rust 中的布尔类型有两个可能的值：true和false。布尔值大小为一个字节。 Rust 中的布尔类型是使用 bool 指定的。例如：

{{<highlight rust>}}
fn main() {
    let t = true;

    let f: bool = false;
}
{{</highlight>}}

#### 字符类型

Rust 的 char 类型是该语言最原始的字母类型。下面是一些声明 char 值的示例：

{{<highlight rust>}}
fn main() {
    let c = 'C';
    let z: char = 'Z';
    let heart_eyed_cat = '😻';
}
{{</highlight>}}

请注意，我们使用单引号指定 char 文字，而不是使用双引号的字符串文字。Rust 的 char 类型大小为 4 个字节，表示一个 Unicode 标量值，这意味着它可以表示的不仅仅是 ASCII。重音字母；中文、日文、韩文字符；表情符号；和零宽度空格在 Rust 中都是有效的 char 值。

## 复合类型

合类型可以将多个值组合为一种类型。 Rust 有两种原始的复合类型：元组和数组。

#### 元祖类型

元组是将具有多种类型的多个值组合成一个复合类型的一般方法。元组具有固定长度：一旦声明，它们的大小就不能增长或缩小。

我们通过在括号内编写一个逗号分隔的值列表来创建一个元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。我们在这个例子中添加了可选的类型注解：

{{<highlight rust>}}
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
{{</highlight>}}

变量 tup 绑定到整个元组，因为元组被认为是单个复合元素。要从元组中获取单个值，我们可以使用模式匹配来解构元组值，如下所示：

{{<highlight rust>}}
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value if y is: {y}");
}
{{</highlight>}}

该程序首先创建一个元组并将其绑定到变量 tup。然后它使用带有 let 的模式来获取 tup 并将其转换为三个单独的变量 x、y 和 z。这称为解构，因为它将单个元组分成三个部分。最后，程序打印出 y 的值，即 6.4。

我们还可以通过使用句点 (.) 后跟我们要访问的值的索引来直接访问元组元素。例如：

{{<highlight rust>}}
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
{{</highlight>}}

该程序创建元组 x，然后使用它们各自的索引访问元组的每个元素。与大多数编程语言一样，元组中的第一个索引是 0。

没有任何值的元组有一个特殊的名称，`unit`。这个值和它对应的类型都写成`()`，代表一个空值或者一个空的返回类型。如果表达式不返回任何其他值，则表达式会隐式返回单位值。

#### 数组类型

另一种收集多个值的方法是使用数组。与元组不同，数组的每个元素都必须具有相同的类型。与其他一些语言中的数组不同，Rust 中的数组具有固定长度。

我们将数组中的值写为方括号内的逗号分隔列表：

{{<highlight rust>}}
fn main() {
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5];
}
{{</highlight>}}

您还可以通过指定初始值、后跟分号和方括号中的数组长度来初始化数组以包​​含每个元素的相同值，如下所示：

{{<highlight rust>}}
let a = [3; 5];
{{</highlight>}}

名为 a 的数组将包含 5 个元素，这些元素最初都将设置为值 3。这与写 `let a = [3, 3, 3, 3, 3];` 相同。但以更简洁的方式。

当您希望将数据分配在堆栈而不是堆上或希望确保始终拥有固定数量的元素时，数组很有用。不过，数组不像向量类型那么灵活。向量是标准库提供的类似集合类型，允许大小增加或缩小。如果您不确定是使用数组还是向量，您可能应该使用向量。但是，当您知道不需要更改元素的数量时，数组会更有用。

###### 访问数组元素

数组是可以在堆栈上分配的已知固定大小的单个内存块。您可以使用索引访问数组的元素，如下所示：

{{<highlight rust>}}
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0]; // 1
    let second = a[1]; // 2
}
{{</highlight>}}
